# üß® Apache Iceberg ‚Äî Day 1

> **Trino Cluster:** `eczachly`  
> **Trino Catalog:** `academy`  
> **Trino Schema:** `javierchiesa`

---

## üì∏ 1. Snapshots

### ‚úÖ Create a partitioned table

```sql
CREATE TABLE javierchiesa.showcase_iceberg (
    col VARCHAR,
    event_date DATE
)
WITH (
    partitioning = ARRAY['event_date']
);
```

### üîç Query snapshots

```sql
SELECT * FROM javierchiesa."showcase_iceberg$snapshots";
```

| committed_at        | snapshot_id         | parent_id | operation | manifest_list | summary |
|---------------------|---------------------|-----------|-----------|----------------|---------|
| 2025-04-17 11:29:16 | 6282228431002613123 | *(null)*  | append    | ...avro        | {...}   |

- **`manifest_list`**: File listing snapshots and their relationships (linked list structure: snapshot ‚Üí parent).
- **`parent_id`**: Points to the previous snapshot. It's null when creating the table (first operation).

### ‚ûï Insert data and see new snapshot

```sql
INSERT INTO javierchiesa.showcase_iceberg 
VALUES ('Hello world', DATE('2025-04-15'));

SELECT * FROM javierchiesa."showcase_iceberg$snapshots";
```

Now there are two snapshots: table creation and the insert.

---

## ‚è≥ 2. Time Travel

### ‚ùå Delete all records

```sql
DELETE FROM javierchiesa.showcase_iceberg;

SELECT * FROM javierchiesa.showcase_iceberg; -- Returns empty
```

### üïê Travel back to a previous snapshot

```sql
SELECT *
FROM javierchiesa.showcase_iceberg 
FOR TIMESTAMP AS OF TIMESTAMP '2025-04-17 15:08:52';
```

| col         | event_date |
|-------------|------------|
| Hello world | 2025-04-15 |

---

## üßπ 3. Partitioning

### üîç Efficient query using exact partition

```sql
SELECT *
FROM javierchiesa.showcase_iceberg 
FOR TIMESTAMP AS OF TIMESTAMP '2025-04-17 15:08:52'
WHERE event_date = DATE('2025-04-15');
```

- ‚úÖ Enables **partition pruning**.

### ‚ö†Ô∏è Inefficient (non-sargable) query

```sql
SELECT *
FROM javierchiesa.showcase_iceberg 
FOR TIMESTAMP AS OF TIMESTAMP '2025-04-17 15:08:52'
WHERE YEAR(event_date) = 2025;
```

- ‚ùå Not sargable ‚Üí No partition pruning possible.
- **Sargable**: Query allows the engine to use indexes/partitions without function transformations.

### ‚úÖ Insert multiple rows

```sql
INSERT INTO javierchiesa.showcase_iceberg
VALUES 
  ('Bye World', DATE('2025-04-17')),
  ('Hello Again', DATE('2025-04-18')),
  ('Test Row 1', DATE('2025-04-19')),
  ('Test Row 2', DATE('2025-04-20')),
  ('Final Row', DATE('2025-04-21'));
```

### üóÉÔ∏è Efficient range query

```sql
SELECT *
FROM javierchiesa.showcase_iceberg 
FOR TIMESTAMP AS OF TIMESTAMP '2025-04-17 15:08:52'
WHERE event_date BETWEEN DATE('2025-01-01') AND DATE('2025-12-31');
```

- ‚úÖ Keeps `event_date` untransformed ‚Üí partition pruning is possible.

---

## üìã 4. Physical Files (`$files`)

```sql
SELECT * FROM javierchiesa."showcase_iceberg$files";
```

- Iceberg uses `lower_bounds` and `upper_bounds` to filter partitions.

### üîç Sargable example

```sql
SELECT *
FROM javierchiesa.showcase_iceberg
WHERE col > 'G';
```

- ‚úÖ Can use file-level metadata.

### ‚ùå Non-sargable example

```sql
SELECT *
FROM javierchiesa.showcase_iceberg
WHERE UPPER(col) > 'G';
```

- ‚ùå Transforms the column ‚Üí full scan needed.

> ‚ö†Ô∏è **General rule:** Keep the left side of your `WHERE` clause clean (no transformations).

---

## üèÄ 5. NBA Table Example

### üß† Explore partitioned files

```sql
SELECT *
FROM bootcamp."nba_player_seasons$files";

SELECT SUM(FILE_SIZE_IN_BYTES)
FROM bootcamp."nba_player_seasons$files"; -- 619,376 bytes
```

### üìÉ Create unpartitioned table

```sql
CREATE TABLE javierchiesa.nba_player_seasons_unpartitioned AS
SELECT * 
FROM bootcamp.nba_player_seasons;

SELECT * FROM javierchiesa."nba_player_seasons_unpartitioned$files"; -- 1 file
```

### ‚öñÔ∏è Compare partitioned vs unpartitioned

```sql
SELECT
  'unpartitioned' AS type,
  SUM(record_count) AS record_count,
  SUM(file_size_in_bytes) AS file_size_in_bytes
FROM javierchiesa."nba_player_seasons_unpartitioned$files"
UNION ALL
SELECT
  'partitioned' AS type,
  SUM(record_count) AS record_count,
  SUM(file_size_in_bytes) AS file_size_in_bytes
FROM bootcamp."nba_player_seasons$files";
```

| type          | record_count | file_size_in_bytes |
|---------------|--------------|--------------------|
| unpartitioned | 12,869       | 238,708            |
| partitioned   | 12,869       | 619,376            |

- Unpartitioned is 60% smaller ‚Üí better compression.
- **Why?** ‚Üí Run-Length Encoding (RLE) is more effective on non-partitioned columnar files.

### ü§î Conclusion

| Case           | Main Benefit          | When to Use                                      |
|----------------|------------------------|--------------------------------------------------|
| **Partitioned** | Query performance      | Large datasets, frequent filtering               |
| **Unpartitioned** | Storage efficiency    | Small/infrequent datasets, prioritize compression |
